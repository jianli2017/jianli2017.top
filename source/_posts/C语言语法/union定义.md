---
title: union定义(转载)
date: 2016-11-21 12:07:12
tags: C 语言语法
categories: C 语言语法
---

# union定义
union 维护足够的空间来置放多个数据成员中的“一种”，而不是为每一个数据成员配置空间，在union 中所有的数据成员共用一个空间，<font color=red size=4 face="黑体">同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。</font>
<!--more-->
例子如下：

	union StateMachine
	{
	   char character;
	   int number;
	   char *str;
	   double exp;
	};

一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长度是double 型态，所以StateMachine 的空间大小就是double 数据类型的大小。

在C++里，union 的成员默认属性页为public。union 主要用来压缩空间。如果一些数据不可能在同一时间同时被用到，则可以使用union。
# 大小端模式对union 类型数据的影响

下面再看一个例子：

	union
	{
	   int i;
	   char a[2];
	}*p, u;
	p =&u;
	p->a[0] = 0x39;
	p->a[1] = 0x38;

p.i 的值应该为多少呢？

这里需要考虑存储模式：大端模式和小端模式。
大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。
小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。
union 型数据所占的空间等于其最大的成员所占的空间。对union 型的成员的存取都是相对于该联合体基地址的偏移量为0 处开始，也就是联合体的访问不论对哪个变量的存取都是从union 的首地址位置开始。如此一解释，上面的问题是否已经有了答案呢？
# 如何用程序确认当前系统的存储模式？

上述问题似乎还比较简单，那来个有技术含量的：请写一个C 函数，若处理器是Big_endian 的，则返回0；若是Little_endian 的，则返回1。

先分析一下，按照上面关于大小端模式的定义，假设int 类型变量i 被初始化为1。

以大端模式存储，其内存布局如下图：![union1](http://of685p9vy.bkt.clouddn.com/union1.jpg)
以小端模式存储，其内存布局如下图：![union2](http://of685p9vy.bkt.clouddn.com/union2.jpg)

变量i 占4 个字节，但只有一个字节的值为1，另外三个字节的值都为0。如果取出低地址上的值为0，毫无疑问，这是大端模式；如果取出低地址上的值为1，毫无疑问，这是小端模式。既然如此，我们完全可以利用union 类型数据的特点：所有成员的起始地址一致。

到现在，应该知道怎么写了吧？参考答案如下：

	int checkSystem( )
	{
	   union check
	   {
	      int i;
	      char ch;
	   } c;
	   c.i = 1;
	   return (c.ch ==1);
	}

# 总结 
union同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址，它所占的空间等于其最大的成员所占的空间，机器的大小端存储影响union成员的取值。
